(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{"+s/W":function(e,t,n){"use strict";n.r(t);var a=n("KHd+"),s=n("UQSp"),r=n("Kw5r");function o(e){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}r.a.config.optionMergeStrategies;var c={VueRemarkRoot:s.a},i=function(e){var t=e.options.components=e.options.components||{},n=e.options.computed=e.options.computed||{};Object.keys(c).forEach((function(e){"object"===o(c[e])&&"function"==typeof c[e].render?t[e]=c[e]:n[e]=function(){return c[e]}}))},p=r.a.config.optionMergeStrategies,l="__vueRemarkFrontMatter",v={excerpt:null,title:"Sending and Receiving"};var d=function(e){e.options[l]&&(e.options[l]=v),r.a.util.defineReactive(e.options,l,v),e.options.computed=p.computed({$frontmatter:function(){return e.options[l]}},e.options.computed)},_=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("VueRemarkRoot",[n("h1",{attrs:{id:"sending-and-receiving"}},[n("a",{attrs:{href:"#sending-and-receiving","aria-hidden":"true"}},[e._v("#")]),e._v("Sending and Receiving")]),n("p",[e._v("Sending and receiving is one of the most important things to understand in Rholang.")]),n("blockquote",[n("p",[e._v("Because Rholang is an asynchronous programming language, there is no return in a function.That's why you call a function "),n("code",{pre:!0},[e._v("HelloWorld(args)")]),e._v(" via sending on the "),n("code",{pre:!0},[e._v("functions")]),e._v(" name HelloWorld. You are sending via the ! syntax.")]),n("p",[e._v("Because of the asynchrony you don't know when the "),n("code",{pre:!0},[e._v("function")]),e._v(" you called via HelloWorld!(args) is sending the processed data "),n("strong",[e._v("back")]),e._v(" over some other channel. Thats why there is no "),n("code",{pre:!0},[e._v("return")]),e._v(" in the "),n("code",{pre:!0},[e._v("function")]),e._v(". Instead Rholang has the for(args<-channels) syntax for waiting until all the needed arguments are received over the channels.")])]),n("h2",{attrs:{id:"example"}},[n("a",{attrs:{href:"#example","aria-hidden":"true"}},[e._v("#")]),e._v("Example")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v('new HelloWorld, stdout(`rho:io:stdout`) in {\n  HelloWorld!("Hello, world!") |\n  for (@text <- HelloWorld) {\n    stdout!(text)\n  }\n}')])]),n("ol",[n("li",[n("p",[e._v("This line declares a new name-valued variable "),n("code",{pre:!0},[e._v("HelloWorld")]),e._v(" and assigns to it a newly-created private name.")])]),n("li",[n("p",[e._v("Every name is of the form "),n("code",{pre:!0},[e._v("@P")]),e._v(", where "),n("code",{pre:!0},[e._v("P")]),e._v(" is a rholang process. The "),n("code",{pre:!0},[e._v("!")]),e._v(" production takes a name "),n("code",{pre:!0},[e._v("n")]),e._v(" on its left and a process "),n("code",{pre:!0},[e._v("P")]),e._v(" on its right, then sends "),n("code",{pre:!0},[e._v("@P")]),e._v(" over the channel named "),n("code",{pre:!0},[e._v("n")]),e._v(". Lineforms the name "),n("code",{pre:!0},[e._v('@"Hello, world"')]),e._v(" and sends it on the channel whose name is stored in the variable "),n("code",{pre:!0},[e._v("HelloWorld")]),e._v(".")])]),n("li",[n("p",[e._v("This "),n("code",{pre:!0},[e._v("for")]),e._v(" production creates a process that waits for a single message to be sent on the channel whose name is stored in the variable "),n("code",{pre:!0},[e._v("HelloWorld")]),e._v(". The pattern "),n("code",{pre:!0},[e._v("@text")]),e._v(" gets matched against the serialized process, binding the process-valued variable "),n("code",{pre:!0},[e._v("text")]),e._v(" to the original process that was sent.")])]),n("li",[n("p",[e._v("Rholang runtime environments may choose to include built-in processes listening on channels. In this tutorial, we use new with the urn "),n("code",{pre:!0},[e._v("rho:io:stdout")]),e._v(" to request a channel where sent messages get printed to a console.")])])]),n("blockquote",[n("p",[e._v("When you send data over a channel and there is no contract which is listening with for(args<-channels) for that channel, then these data is stored in the tuplespace (like a database), until some contract is starting to listening for it.")])]),n("h3",{attrs:{id:"name-equivalence"}},[n("a",{attrs:{href:"#name-equivalence","aria-hidden":"true"}},[e._v("#")]),e._v("Name Equivalence")]),n("p",[e._v("It is possible to write one single name in several different ways. For example, the two following channels are equivalent:")]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")])])]),n("p",[e._v("Any message sent over these channels can be received by listening on the channel "),n("code",{pre:!0},[e._v("@12")]),e._v(". There are other instances in which a name can be written in two different ways. The guiding principle for this is that if "),n("code",{pre:!0},[e._v("P")]),e._v(" and "),n("code",{pre:!0},[e._v("Q")]),e._v(" are two equivalent processes, then "),n("code",{pre:!0},[e._v("@P")]),e._v(" and "),n("code",{pre:!0},[e._v("@Q")]),e._v(" are equivalent names. In particular, all of the following channels are equivalent:")]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("P")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("Q")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("Q")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("P")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("Q")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[e._v("P")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token maybe-class-name"}},[e._v("Nil")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")])])]),n("p",[e._v("Before using a channel, Rholang first evaluates expressions and accounts for these "),n("code",{pre:!0},[e._v("|")]),e._v(" rules at the top level--but only at the top level. This means that if an arithmetic expression forms part of a pattern within a pattern, it is left untouched. Because of this,")]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",{pre:!0,attrs:{class:"language-javascript"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v(" @"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" @"),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"chan"')]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token spread operator"}},[e._v("...")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")])])]),n("p",[e._v("will never receive any message on "),n("code",{pre:!0},[e._v('@"chan"')]),e._v(" since if we send anything, such as "),n("code",{pre:!0},[e._v("10 + 5")]),e._v(", over "),n("code",{pre:!0},[e._v('@"chan"')]),e._v(", the arithmetic expression gets evaluated and the name "),n("code",{pre:!0},[e._v("@15")]),e._v(" is sent.")]),n("p",[e._v("Finally, channels also respect a change in variable name (alpha equivalence), so the following channels are equivalent:")]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",{pre:!0,attrs:{class:"language-javascript"}},[e._v("@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" chan "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token spread operator"}},[e._v("...")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n@"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v(" z "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" chan "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token spread operator"}},[e._v("...")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")])])]),n("h2",{attrs:{id:"replicated-receive"}},[n("a",{attrs:{href:"#replicated-receive","aria-hidden":"true"}},[e._v("#")]),e._v("Replicated receive")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v('new HelloWorld, stdout(`rho:io:stdout`) in {\n  for (@text <= HelloWorld) {\n    stdout!(text)\n  } |\n  HelloWorld!("Hello, world!") |\n  HelloWorld!("Hola, mundo!")\n}')])]),n("p",[e._v("2.) Instead of handling only a single message, a "),n("code",{pre:!0},[e._v("for")]),e._v(" using a double arrow "),n("code",{pre:!0},[e._v("<=")]),e._v(" will persist, spawning a copy of the body for each message received.")]),n("p",[e._v("5-6) We send the string processes "),n("code",{pre:!0},[e._v('"Hello, world!"')]),e._v(" and "),n("code",{pre:!0},[e._v('"Hola, mundo!"')]),e._v(" on the channel "),n("code",{pre:!0},[e._v("HelloWorld")]),e._v(". It is non-deterministic which message will be processed first.")]),n("h2",{attrs:{id:"contracts-as-sugar-for-replicated-receive"}},[n("a",{attrs:{href:"#contracts-as-sugar-for-replicated-receive","aria-hidden":"true"}},[e._v("#")]),e._v("Contracts as sugar for replicated receive")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v('new HelloWorld, stdout(`rho:io:stdout`) in {\n  contract HelloWorld(@text) = {\n    stdout!(text)\n  } |\n  HelloWorld!("Hello, world!") |\n  HelloWorld!("Hola, mundo!")\n}')])]),n("p",[e._v("2.) The only difference between this example and the last one is this line. The "),n("code",{pre:!0},[e._v("contract")]),e._v(" production is syntactic sugar. The process "),n("code",{pre:!0},[e._v("contract Name(...formals) = { P }")]),e._v(" means the same as "),n("code",{pre:!0},[e._v("for (...formals <= Name) { P }")]),e._v(".")]),n("h2",{attrs:{id:"replicated-send"}},[n("a",{attrs:{href:"#replicated-send","aria-hidden":"true"}},[e._v("#")]),e._v("Replicated send")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v('new HelloWorld, stdout(`rho:io:stdout`), stderr(`rho:io:stderr`) in {\n  HelloWorld!!("Hello, world!") |\n  for (@text <- HelloWorld) {\n    stdout!(text)\n  } |\n  for (@text <- HelloWorld) {\n    stderr!(text)\n  }\n}')])]),n("p",[e._v("2.) The double-bang "),n("code",{pre:!0},[e._v("!!")]),e._v(" means that this message will be sent again as soon as it is read.")]),n("p",[e._v("3-4, 6-7) There are two listening processes; each one consumes a single message from the channel and forwards it to either "),n("code",{pre:!0},[e._v('"stdout"')]),e._v(" or "),n("code",{pre:!0},[e._v('"stderr"')]),e._v(". The order in which they get forwarded to those channels is nondeterministic.")]),n("h2",{attrs:{id:"sequential-send"}},[n("a",{attrs:{href:"#sequential-send","aria-hidden":"true"}},[e._v("#")]),e._v("Sequential send")]),n("p",[e._v("In order to have one message follow after another is known to have been received, we must use an acknowledgement message.")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v("new chan, ack, stdoutAck(`rho:io:stdoutAck`) in {\n  chan!(0) |\n  for (_ <- ack) {\n    chan!(1)\n  } |\n  for (@num <= chan) {\n    stdoutAck(num, *ack)\n  }\n}")])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("We send the message 0 on "),n("code",{pre:!0},[e._v("chan")]),e._v(".")]),n("li",[e._v("We wait for a message on the channel "),n("code",{pre:!0},[e._v("ack")]),e._v(", throw it away, and then proceed with the body.")]),n("li",[e._v("We send the messageon "),n("code",{pre:!0},[e._v("chan")]),e._v(".")]),n("li",[e._v("We listen persistently for messages sent on "),n("code",{pre:!0},[e._v("chan")]),e._v(".")]),n("li",[e._v("We forward each message to the channel "),n("code",{pre:!0},[e._v('"stdoutAck"')]),e._v(", which expects both a value to print and a channel on which to send an acknowledgement message that the text has been received and printed. In this program, we are guaranteed that 0 will be printed before 1.")])]),n("h2",{attrs:{id:"sending-and-receiving-multiple-processes"}},[n("a",{attrs:{href:"#sending-and-receiving-multiple-processes","aria-hidden":"true"}},[e._v("#")]),e._v("Sending and receiving multiple processes")]),n("pre",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[n("code",{pre:!0,attrs:{class:"language-javascript{numberLines:"}},[e._v('new chan, stdout(`rho:io:stdout`) in {\n  chan!(1,2,3) |\n  chan!((4,5,6)) |\n  chan!(7,8) |\n  chan!([9, 10], 11) |\n  chan!(12 | 13) |\n  for (@x, @y, @z <= chan) {\n    stdout!(["three", x, y, z])\n  } |\n  for (@a, @b <= chan) {\n    stdout!(["two", a, b])\n  } |\n  for (@a <= chan) {\n    stdout!(["one", a])\n  }\n}')])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("We send three numeric processes on "),n("code",{pre:!0},[e._v("chan")]),e._v(". This send necessarily synchronizes with the "),n("code",{pre:!0},[e._v("for")]),e._v(" on line 7.")]),n("li",[e._v("We send one tuple process on "),n("code",{pre:!0},[e._v("chan")]),e._v(". This send necessarily synchronizes with the "),n("code",{pre:!0},[e._v("for")]),e._v(" on line 13.")]),n("li",[e._v("We send two numeric processes on "),n("code",{pre:!0},[e._v("chan")]),e._v(". This send necessarily synchronizes with the "),n("code",{pre:!0},[e._v("for")]),e._v(" on line 10.")]),n("li",[e._v("We send a list process and a numeric process on "),n("code",{pre:!0},[e._v("chan")]),e._v(". This send necessarily synchronizes with the "),n("code",{pre:!0},[e._v("for")]),e._v(" on line 10.")]),n("li",[e._v("We send a single process that is the par of two numeric expressions on "),n("code",{pre:!0},[e._v("chan")]),e._v(". This send necessarily synchronizes with the "),n("code",{pre:!0},[e._v("for")]),e._v(" on line 13.")])])])}),[],!1,null,null,null);"function"==typeof i&&i(_),"function"==typeof d&&d(_);t.default=_.exports},UQSp:function(e,t,n){"use strict";t.a={name:"VueRemarkRoot",render:function(e){return e("div",null,this.$slots.default)}}}}]);